# 内存申请和释放

## ✏ 1、`malloc & free`

### 🖋 1.1、`malloc`使用方式

`malloc`函数可以从堆上获得指定字节的内存空间，其函数声明如下：

```cpp
void * malloc(size_t size);
```

其中，形参n为要求分配的字节数。如果函数执行成功，`malloc`返回获得内存空间的首地址；如果函数执行失败，那么返回值为NULL。由于`malloc`函数值的类型为void型指针，因此，可以将其值类型转换后赋给任意类型指针，这样就可以通过操作该类型指针来操作从堆上获得的内存空间。`malloc`申请的空间是连续的。size\_t数据类型经常用到，在 `32 bit` 编译器中是`unsigned int`；在`64 bit`系统中是`unsigned __int64`。`malloc(0)`返回一个有效的空间长度为零的内存首地址，但是没法用\(只进行申请和释放可以，如申请后执行了写操作，释放时会报错\)。

#### 💎 1.1.1、动态申请

**动态申请数组**

```cpp
int* p = (int*)malloc(sizeof(int) * 6);
```

申请一个有6个整形数组元素的一维数组，申请完不能初始化，只能通过`memset()`或循环的方式赋值。因该操作程序运行到这条语句时才在堆区申请的数组，所以被称为动态申请内存\(数组\)，栈区的数组在编译时就已经申请好内存了，所以不是动态申请的。

**动态申请数组指针**

```cpp
int (*p)[3] = (int(*)[3])malloc(sizeof(int) * 3);       // 一维数组指针
int (*q)[2][3] = (int(*)[2][3])malloc(sizeof(int) * 6); // 二维数组指针
```

#### 💎 1.1.2、初始化

需要注意的是，`malloc`函数分配得到的内存空间是未初始化的。因此，一般在使用该内存空间时，要调用另一个函数`memset`来将其初始化为全0。`memset`函数的声明如下：

```cpp
void* memset(void* dest, int c, size_t count);
```

该函数可以将指定的内存空间按字节单位置为指定的字符c。其中，`dest`为要清零的内存空间的首地址，c为要设定的值，count为被操作的内存空间的字节长度。

```cpp
void* memcpy(void* dest, void* src, size_t count);
```

此函数也是按照字节进行拷贝的，`dest`指向目标地址的指针，也就是要被赋值的空间首地址；`src`指向源地址的指针，也就是要被复制的空间的首地址；count跟`memset()`一样表示被拷贝的字节数；返回值也是被赋值的目标地址的指针。

### 🖋 1.2、`malloc`的申请过程

### 🖋 1.3、其他申请方式

### 🖋 1.4、`free`使用方式

用`malloc()`申请一块内存空间，OS会有一张表记录所申请空间的首地址和这块地址的长度，free\(空间首地址\)，free会从表中查找到这块首地址对应的内存大小，一并释放掉。

1. free\(\)不能去释放栈区的空间，栈区空间是由OS管理的，由OS进行申请和释放。
2. 释放空间后，指针需要置空，避免成为野指针。

```cpp
int* p = (int*)malloc(sizeof(int));
if (p == NULL) { // p 是空指针
    // 空间申请失败的错误处理
} else {
    // 申请成功，假设 p == 0X00000191D34DDAB0;
    free(p);  // p == 0X00000191D34DDAB0; p有值，但是指向的内存空间已经被释放掉了，p就成了一个野指针了
    p = NULL; // 释放空间后，指针需要置空，避免成为野指针
}
int *p;       //这种，定义完指针未初始化，也是野指针

int* q = (int*)malloc(3);
free(q);  // 会报错，int型指针一次操作 4Byte，这里只申请了 3Byte 相当去别人的地盘上拆东西，那肯定是不允许的
int* n = (int*)malloc(7); // 允许多申请，但是 int型指针一次只能操作 4Byte 多余的空间浪费了
free(n);  // 释放时，从OS维护的表中查找到空间长度，会一并释放掉
```

## ✏ 2、`new & delete`

### 🖋 2.1、new的使用





