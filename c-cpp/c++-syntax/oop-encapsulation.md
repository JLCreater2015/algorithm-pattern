# 面向对象之封装

## ✏ 1、面向对象编程

C++ 在 C 语言的基础上增加了面向对象编程（`OOP`），C++ 支持面向对象程序设计。类是 C++ 的核心特性，通常被称为用户定义的类型。

### 🖋 1.1、类和对象

类用于**指定对象的形式**，它包含了**数据表示法**和**用于处理数据的方法**。**类中的数据和方法称为类的成员**。**函数在一个类被称为类的成员**。 **对象是根据类来创建的，声明类的对象，就像声明基本类型的变量一样**。

### 🖋 1.2、三大特性

* 封装性：数据和代码捆绑在一起，避免外界干扰和不确定性访问，封装可以使得代码模块化。

  优点：

  * 确保用户代码不会无意间破坏封装对象的状态
  * 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码

* 继承性：让某种类型对象获得另一个类型对象的属性和方法，继承可以扩展已存在的代码。
* 多态性：同一事物表现出不同事物的能力，即向不同对象发送同一消息，不同的对象在接收时会产生不同的行为（重载实现编译时多态，虚函数实现运行时多态），多态的目的则是为了接口重用。

### 🖋 1.3、基本概念

| 概念 | 描述 |
| :--- | :--- |
| 类成员函数 | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |
| 类访问修饰符 | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |
| 构造函数 & 析构函数 | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |
| 拷贝构造函数 | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |
| 友元函数 | 友元函数可以访问类的 private 和 protected 成员。 |
| 内联函数 | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |
| this指针 | 每个对象都有一个特殊的指针 this，它指向对象本身。 |
| 指向类对象的指针 | 指向类的指针方式如同指向结构的指针。实际上，类可以看成是一个带有函数的结构。 |
| 类的静态成员 | 类的数据成员和函数成员都可以被声明为静态的。 |
| 类型转换函数 | 转换构造函数可以将普通的基础类型转换为当前的类类型，也可以将其它类类型的对象转换为当前的类类型。 |
| 运算符重载 |  |

### 🖋 1.4、封装的例子

在这里先给出一个封装好的学生类：

```text

```

## ✏ 2、构造函数 & 析构函数

### 🖋 2.1、构造函数

**构造函数（`constructor`）**是类的一种特殊的成员函数，它会在每次创建类的新对象时执行。构造函数的名称与类的名称是完全相同的，并且不会返回任何类型，也不会返回 void。构造函数可用于为某些成员变量设置初始值。类对象被创建的时候，编译系统对象分配内存空间，并自动调用类的构造函数，由构造函数完成成员的初始化工作，故：**构造函数的作用是初始化对象的数据成员。**

#### 🐹 **2.1.1、构造函数重载**

和普通成员函数一样，构造函数是允许重载的。一个类可以有多个重载的构造函数，创建对象时根据传递的实参来判断调用哪一个构造函数。

构造函数的调用是强制性的，一旦在类中定义了构造函数，那么创建对象时就一定要调用，不调用是错误的。如果有多个重载的构造函数，那么创建对象时提供的实参必须和其中的一个构造函数匹配；反过来说，创建对象时只有一个构造函数会被调用。

#### 🐹 2.1.**2**、默认构造函数

这里我们将默认构造函数定义为：无参的构造函数或者所有参数都有默认值的构造函数（二者不属于重重载的关系，一个类只能有一个默认构造函数）。这里的无参构造函数可以是显示定义的也可以是编译器自动生成的。调用默认构造函数也可以省略括号，即用下面的方式创建对象时调用的构造函数可以看成是默认的构造函数：

```cpp
Student stu1;
Student stu2();

Student *pstu1 = new Student;
Student *pstu2 = new Student();
```

编译器自动生成的默认构造函数：C++标准规定，如果类中没有显示定义构造函数，则编译器会自动生成一个默认的构造函数，这个构造函数的函数体是空的，也没有形参，也不执行任何操作，叫做无关紧要（`trivial`）的默认构造函数。**即：一个类必须有构造函数，要么用户自己定义，要么编译器自动生成。一旦用户自己定义了构造函数，不管有几个，也不管形参如何，编译器都不再自动生成。**

> 实际上编译器只有在必要的时候才会生成默认构造函数，而且它的函数体一般不为空，即非平凡（non-`trivival`）默认构造函数。默认构造函数的目的是帮助编译器做初始化工作。默认构造函数不为空的情况见这里。

#### 🐹 2.1.2、成员初始化方式——初始化列表

构造函数的一项重要功能是对成员变量进行初始化，为了达到这个目的，可以在构造函数的函数体中对成员变量一一赋值，还可以采用初始化列表。

* 使用构造函数初始化列表并没有效率上的优势，仅仅是书写方便，尤其是成员变量较多时，这种写法非常简单明了。
* 成员变量的初始化顺序与初始化列表中列出的变量的顺序无关，它只与成员变量在类中声明的顺序有关。
* **初始化 const 成员变量的唯一方法就是使用初始化列表。**

### 🖋 2.2、拷贝构造函数

复制构造函数是构造函数的一种，也称拷贝构造函数，它只有一个参数，参数类型是本类的引用。

* 复制构造函数的参数可以是 const 引用，也可以是非 const 引用。 一般使用前者，这样既能以常量对象（初始化后值不能改变的对象）作为参数，也能以非常量对象作为参数去初始化其他对象。一个类中写两个复制构造函数，一个的参数是 const 引用，另一个的参数是非 const 引用，也是可以的。
* 如果类的设计者不显示定义复制构造函数，编译器就会自动生成复制构造函数。大多数情况下，其作用是实现从源对象到目标对象逐个字节的复制，即使得目标对象的每个成员变量都变得和源对象相等。编译器自动生成的复制构造函数称为“默认复制构造函数”。默认构造函数（即无参构造函数）不一定存在，但是复制构造函数总是会存在。
* 构造函数不能以本类的对象作为唯一参数，以免和复制构造函数相混淆。例如，不能写如下构造函数：`Complex (Student stu) {...}`

#### 🐹 2.2.1、复制构造函数调用的时机

1. 当用一个对象去初始化同类的另一个对象时，会引发复制构造函数被调用。
2. 如果函数 F 的参数是类 A 的对象，那么当 F 被调用时，类 A 的复制构造函数将被调用。换句话说，作为形参的对象，是用复制构造函数初始化的，而且调用复制构造函数时的参数，就是调用函数时所给的实参。由此可见：函数的形参的值等于函数调用时对应的实参，不一定是正确的。如果形参是一个对象，那么形参的值是否等于实参，取决于该对象所属的类的复制构造函数是如何实现的。
3. 如果函数的返冋值是类 A 的对象，则函数返冋时，类 A 的复制构造函数被调用。换言之，作为函数返回值的对象是用复制构造函数初始化 的，而调用复制构造函数时的实参，就是 return 语句所返回的对象。 需要说明的是，有些编译器出于程序执行效率的考虑，编译的时候进行了优化，函数返回值对象就不用复制构造函数初始化了，这并不符合 C++ 的标准。

```cpp
class Student
{
public:
    Student()
    {
        cout << "调用了默认构造函数！" << endl;
    }
    Student(int id, char sex) : id(id), sex(sex)
    {
        cout << "调用了初始化构造函数！" << endl;
    }
    Student(const Student& stu)
    {
        cout << "调用了拷贝构造函数！" << endl;
    }
public:
    int id;
    char sex;
};

Student change(Student s)
{
    Student stu(s.id + 1, s.sex);
    return stu;
}

int main()
{
    Student stu1;
    Student stu2(stu1);
    Student stu3 = change(stu2);
    return 0;
}

// 输出
调用了默认构造函数！
调用了拷贝构造函数！
调用了拷贝构造函数！
调用了初始化构造函数！
调用了拷贝构造函数！
```

> 构造函数调用顺序：
>
> 1. 当普通构造一个对象时，程序先自动调用默认构造函数分配空间，再调用自定义构造函数（如果有的话）。
> 2. 当拷贝构造一个对象时，程序先自动调用默认构造函数分配空间，然后分两种情况，如果程序有自定义拷贝构造函数，则调用自定义拷贝构造函数；如果没有自定义拷贝构造函数，那么就调用默认拷贝构造函数进行浅拷贝。

> 注意：2的情况下，当程序自定义拷贝构造函数了，那么程序是不会调用默认构造函数进行浅拷贝，我们需要在自定义的拷贝构造函数里把所有需要拷贝的成员变量都写上，无论是要深拷贝还是浅拷贝。

#### 🐹 2.2.2、浅拷贝和深拷贝



### 🖋 2.3、析构函数

**析构函数（`Destructor`）**也是一种特殊的成员函数，没有返回值，不需要程序员显式调用（程序员也没法显式调用），而是在销毁对象时自动执行。构造函数的名字和类名相同，而析构函数的名字是在类名前面加一个`~`符号。

* 析构函数没有参数，不能被重载，因此一个类只能有一个析构函数。如果用户没有定义，编译器会自动生成一个默认的析构函数。

#### 🐹 2.3.1、析构函数调用的时机

* 在所有函数之外创建的对象是全局对象，它和全局变量类似，位于内存分区中的全局数据区，程序在结束执行时会调用这些对象的析构函数。
* 在函数内部创建的对象是局部对象，它和局部变量类似，位于栈区，函数执行结束时会调用这些对象的析构函数。
* new 创建的对象位于堆区，通过 delete 删除时才会调用析构函数；如果没有 delete，析构函数就不会被执行。

#### 🐹 2.3.2、自定义析构函数

默认析构函数只会释放类的普通数据所占用的空间， **但是像`new`或者`malloc`申请的堆的内存，它是不会去释放的，所以这部分需要我们自己做。**因此需要显示定义并实现析构函数。

在自定义析构函数中，主要做：

1. 一些用户自己申请的堆内存（`new / malloc`）的释放。 
2. 系统资源的释放（`FILE*`等等）。

> 析构时，编译器先调用自定义析构函数（如果有的话），释放一些引用的堆内存，系统资源等等；然后，再调用默认析构函数，对类的一些普通数据所占用的内存进行释放。

在C++中复制控制是一个比较重要的话题，主要包括复制构造函数、重载赋值操作符、析构函数这三部分，这三个函数是一致的，如果类需要析构函数，则它也需要复制操作符 和 复制构造函数，这个规则被称为 C++的**“三法则”**。如果需要手动定义了其中了一个，那么另外的两个也需要定义，通常在存在指针或者前期相关操作的情况下，都需要手动的定义。

## ✏ 3、类访问修饰符

数据封装是面向对象编程的一个重要特点，它防止函数直接访问类类型的内部成员。类成员的访问限制是通过在类主体内部对各个区域标记 **public、private、protected** 来指定的。关键字 **public、private、protected** 称为访问修饰符。

一个类可以有多个 public、protected 或 private 标记区域。每个标记区域在下一个标记区域开始之前或者在遇到类主体结束右括号之前都是有效的。成员和类的默认访问修饰符是 private。

1.  **公有**成员在程序中类的外部是可访问的。
2.  **私有**成员变量或函数在类的外部是不可访问的，甚至是不可查看的。只有类和友元函数可以访问私有成员。
3.  **保护**成员变量或函数与私有成员十分相似，但有一点不同，保护成员在派生类（即子类）中是可访问的。

## ✏ 4、运算符重载



## ✏ 5、类型转换函数

## ✏ 6、类的指针和this指针



## ✏ 7、友元函数和友元类



## ✏ 8、类的静态成员



