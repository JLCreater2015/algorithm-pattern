# lambda表达式

匿名函数有函数体，但没有函数名。匿名函数是很多高级语言都支持的概念，如lisp语言在1958年首先采用匿名函数。C++11中引入了lambda函数。利用`lambda`表达式可以编写内嵌的匿名函数，用以替换独立函数或者函数对象，并且使代码更可读。但是从本质上来讲，`lambda`表达式只是一种语法糖，因为所有其能完成的工作都可以用其它稍微复杂的代码来实现。但是它简便的语法却给`C++`带来了深远的影响。如果从广义上说，`lamdba`表达式产生的是函数对象。

> 相同类似功能我们也可以使用**函数对象**或者**函数指针**实现：函数对象能维护状态，但语法开销大，而函数指针语法开销小，却没法保存范围内的状态。lambda表达式正是结合了两者的优点。

## ✏ 1、Lambda表达式

### 🖋 1.1、声明Lambda表达式

```cpp
[capture list] (params list) mutable exception -> return type { function body };
[capture list] (params list) -> return type {function body};  //1
[capture list] (params list) {function body};		//2
[capture list] {function body};		//3
```

* capture list：捕获外部变量列表
* params list：形参列表
* mutable指示符：用来说用是否可以修改捕获的变量
* exception：异常设定
* return type：返回类型
* function body：函数体

标号1. 函数声明了一个const类型的表达式，此声明不可改变capture list中的捕获的值。

标号2. 函数省略了返回值，此时如果function body内含有return语句，则按return语句返回类型决定返回值类型，若无则返回值为void类型。

标号3. 函数无参数列表，意味无参函数。

```cpp
vector<int> vec{1,0,9,5,3,3,7,8,2};
sort(lbvec.begin(), lbvec.end(), [](int a, int b) -> bool { return a < b; });  
```

### 🖋 1.2、捕获外部变量

`lambda`表达式最前面的方括号的意义何在？其实这是`lambda`表达式一个很Hong要的功能，就是闭包。这里我们先讲一下`lambda`表达式的大致原理：每当你定义一个`lambda`表达式后，编译器会自动生成一个匿名类（这个类当然重载了`()`运算符），我们称为闭包类型（closure type）。那么在运行时，这个`lambda`表达式就会返回一个匿名的闭包实例，其实一个右值。所以，我们上面的`lambda`表达式的结果就是一个个闭包。闭包的一个强大之处是其可以通过传值或者引用的方式捕捉**其封装作用域内的变量**，前面的方括号就是用来定义捕捉模式以及变量，我们又将其称为`lambda`捕捉块。

Lambda表达式可以捕获外面变量，但需要我们提供一个谓词函数（\[capture list\]在声明表达式最前）。类似参数传递方式：值传递、引入传递、指针传递。在Lambda表达式中，外部变量捕获方式也类似：**值捕获、引用捕获、隐式捕获**。

#### 值捕获

```cpp
int a = 123;
auto f = [a] { cout << a << endl; }; 
f(); // 输出：123
a = 321;
f(); // 输出：123
```

值捕获和参数传递中的**值传递**类似，被捕获的值在Lambda表达式创建时通过**值拷贝**的方式传入，因此**Lambda表达式函数体中不能修改该外部变量的值**；同样，函数体外对于值的修改也不会改变被捕获的值。

#### 引用捕获

```cpp
int a = 123;
auto f = [&a] { cout << a << endl; }; 
a = 321;
f(); // 输出：321
```

引用捕获的变量使用的实际上就是该引用所绑定的对象，因此引用对象的改变会改变函数体内对该对象的引用的值。

#### 隐式捕获

隐式捕获有两种方式，分别是  
\[=\]：以值补获的方式捕获外部**所有变量**  
\[&\]：表示以引用捕获的方式捕获外部**所有变量**。

```cpp
int a = 123, b=321;
auto df = [=] { cout << a << b << endl; };    // 值捕获
auto rf = [&] { cout << a << b << endl; };    // 引用捕获
```

#### 其他捕获方式

| 捕获外部变量形式 |  |
| :--- | :--- |
| \[ \] | 不捕获任何变量（无参函数） |
| \[变量1,&变量2, …\] | 值\(引用\)形式捕获指定的多个外部变量 |
| \[this\] | 值捕获this指针 |
| \[=, &x\] | 变量x以引用形式捕获，其余变量以传值形式捕获 |
| \[\*this\] | 通过传值方式捕获当前对象 |
| \[&, x\] | 默认以引用捕获所有变量，但是x是例外，通过值捕获 |

### 🖋 1.3、参数

* 参数列表中不能有默认参数
* 不支持可变参数
* 所有参数必须有参数名

### 🖋 1.4、mutable

 将`lambda`表达式标记为`mutable`，实现的函数调用运算符是非const属性的。对于引用捕获方式，无论是否标记`mutable`，都可以在`lambda`表达式中修改捕获的值。至于闭包类中是否有对应成员，`C++`标准中给出的答案是：不清楚的，看来与具体实现有关。既然说到了深处，还有一点要注意：`lambda`表达式是不能被赋值的：  


