# 重要的关键字（一）

## ✏ 1、`auto`

在早期C/C++中`auto`的含义是：使用auto修饰的变量，是具有自动存储器的局部变量。C++11中，`auto`有了全新的含义即：`auto`不再是一个存储类型指示符，而是作为一个新的类型指示符来指示编译器，`auto`声明的变量必须由编译器在编译时期推导而得。通俗地讲，`auto`关键字是可以自动推导变量类型的。

> auto不是一个类型的“声明”，而是一个“占位符”，编译器在编译期会将`auto`替换为变量实际的类型。使用`auto`定义变量时必须对其进行初始化，在编译阶段编译器需要根据初始化表达式来推导`auto`的实际类型。它自动推导变量类型是根据`“=”`右侧的变量类型决定的。

### 使用规则

**1. auto与指针和引用结合起来使用**

用`auto`声明指针类型时，用`auto`和`auto*`没有任何区别，但用`auto`声明引用类型时则必须加`&`。

**2. 在同一行定义多个变量**

当在同一行声明多个变量时，这些变量**必须是相同的类型，**否则编译器将会报错，因为编译器实际只对  
第一个类型进行推导，然后用推导出来的类型定义其他变量。 

**3. auto不能作为函数的参数**

参数要被编译成指令，但是开辟空间时候需要知道空间大小，`auto`做参数不知道多大，那么栈帧也不知道开多大。

**4. auto不能直接用来声明数组**

因为数组也涉及大小，在下面的例子中，a的类型严格来说是 int \[3\]，所以b的大小也不确定。

```cpp
int a[] = {1,2,3};
auto b[3] = a;
```

**5. auto在实际中最常见的优势用法是C++11提供的新式for循环，还有lambda表达式等进行配合使用。**

**6. auto不能定义类的非静态成员变量。**

**7. 实例化模板时不能使用auto作为模板参数。**

## ✏ **2、mutable**

\*\*\*\*

## ✏ **3、static**

\*\*\*\*

## ✏ **4、volatile**

 C/C++ 中的 volatile 关键字和 const 对应，用来修饰变量，通常用于建立语言级别的 memory barrier。

volatile 关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。当要使用 volatile 声明的变量的值的时候，系统总是重新从它所在的内存读取数据，即使它前面的指令刚刚从该处读取过数据。而且读取的数据立刻被保存。

```cpp
volatile int i=10;
int a = i;
 ... // 其他代码，并未明确告诉编译器，对 i 进行过操作
int b = i;
```

volatile 指出 i 是随时可能发生变化的，每次使用它的时候必须从 i的地址中读取，因而编译器生成的汇编代码会重新从i的地址读取数据放在 b 中。而优化做法是，由于编译器发现两次从 i读数据的代码之间的代码没有对 i 进行过操作，它会自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错，所以说 volatile 可以保证对特殊地址的稳定访问。注意，在 `VC 6.0` 中，一般调试模式没有进行代码优化，所以这个关键字的作用看不出来。

```cpp
#include <stdio.h>	 
void main(){
   int i = 10;
   int a = i;
   printf("i = %d ", a);	 
   // 下面汇编语句的作用就是改变内存中 i 的值
   // 但是又不让编译器知道
   __asm {
      mov dword ptr [ebp-4], 20h  
      // EBP：基址指针寄存器(extended base pointer)，其内存放着一个指针，
      // 该指针永远指向系统栈最上面一个栈帧的底部。
   }
   int b = i;
   printf("i = %d", b);
}
```

分别在 Debug 和 Release 版本运行程序，输出都是：`i = 10 i = 10`

如果将变量`i`声明成`volatile int i = 10;`，则在 Debug 下输出为`i = 10 i = 10`，在Release下输出为`i = 10 i = 32`。（测试环境：`Visual Studio 2019——MSVC16.0`）

说明这个 volatile 关键字发挥了它的作用。其实不只是“内嵌汇编操纵栈”这种方式属于编译无法识别的变量改变，另外更多的可能是多线程并发访问共享变量时，一个线程改变了变量的值，怎样让改变后的值对其它线程 visible。一般说来，volatile用在如下的几个地方：

1. 中断服务程序中修改的供其它程序检测的变量需要加volatile； 
2. 多任务环境下各任务间共享的标志应该加volatile； 
3. 存储器映射的硬件寄存器通常也要加volatile说明，因为每次对它的读写都可能由不同意义；

### 🖋 4.1、volatile与指针

和 const 修饰词类似，const 有常量指针和指针常量的说法，volatile 也有相应的概念：

* 修饰由指针指向的对象、数据是 volatile 的：`volatile char *vpch;`
* 指针自身的值——一个代表地址的整数变量，是 volatile 的：`char* volatile pchv;`

注意：

1. 可以把一个非 volatile int 赋给 volatile int，但是不能把非 volatile 对象赋给一个 volatile 对象。
2. 除了基本类型外，对用户定义类型也可以用 volatile 类型进行修饰。
3. C++中一个有 volatile 标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用const\_cast 来获得对类型接口的完全访问。此外，volatile 向 const 一样会从类传递到它的成员。

### 🖋 4.2、 **多线程下的volatile**   

有些变量是用volatile关键字声明的。当两个线程都要用到某一个变量且该变量的值会被改变时，应该用volatile声明，该关键字的作用是防止优化编译器把变量从内存装入CPU寄存器中。如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。volatile的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值**：**

```cpp
volatile bool bStop = FALSE;  
// (1) 在一个线程中：  
    while( !bStop ) { ... }  
    bStop  =  FALSE;  
    return;    
// (2) 在另外一个线程中，要终止上面的线程循环：  
    bStop = TRUE;  
    while( bStop ); //等待上面的线程终止，如果bStop不使用volatile申明，
                    //那么这个循环将是一个死循环，因为bStop已经读取到了寄存器中，
                    //寄存器中bStop的值永远不会变成FALSE，加上volatile，
                    //程序在执行时，每次均从内存中读出bStop的值，就不会死循环了。
```

这个关键字是用来设定某个对象的存储位置在内存中，而不是寄存器中。因为一般的对象编译器可能会将其的拷贝放在寄存器中用以加快指令的执行速度。

## ✏ **5、extern**

\*\*\*\*

