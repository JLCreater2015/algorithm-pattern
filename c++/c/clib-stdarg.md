# C标准库之stdarg

## ✏ 1、可变长参数

C语言支持可变长参数，正常情况下C的函数参数入栈规则为`__stdcall`，它是从右到左的，即函数中的最右边的参数最先入栈。例如，对于函数：

```cpp
void func(int a, char b, int c, double d, int e) {
    int f = 0;
    printf("&a = 0x%p\n", &a);
    printf("&b = 0x%p\n", &b);
    printf("&c = 0x%p\n", &c);
    printf("&d = 0x%p\n", &d);
    printf("&e = 0x%p\n", &e);
    printf("&f = 0x%p\n", &f);
}
// 输出
&a = 0x0058F968   
&b = 0x0058F96C  // 4  字对齐
&c = 0x0058F970  // 4
&d = 0x0058F974  // 4
&e = 0x0058F97C  // 8
&f = 0x0058F954  
```

用户栈是从上往下生长的，先占用高地址的空间，再占用低地址空间。对于在32位系统的多数编译器，每个栈单元的大小都是`sizeof(int)`，而函数的每个参数都至少要占一个栈单元大小。对于固定参数列表的函数，每个参数的名称、类型都是直接可见的，他们的地址也都是可以直接得到的。

按照C标准的说明，支持变长参数的函数在原型声明中，**必须有至少一个最左固定参数**\(这一点与传统C有区别，传统C允许不带任何固定参数的纯变长参数函数\)，这样我们可以得到其中固定参数的地址，根据上面的参数入栈顺序，我们可尝试写一个可变长参数的函数：

```cpp
void var_args_func(const char* fmt, ...)
{
    char* ap;
    ap = ((char*)&fmt) + sizeof(fmt);
    printf("%d\n", *(int*)ap);
    ap = ap + sizeof(int);
    printf("%d\n", *(int*)ap);
    ap = ap + sizeof(int);
    printf("%s\n", *((char**)ap));
}
```

解释：用`ap`获取第一个变参的地址，我们知道第一个变参是4，一个int 型，所以我们用`(int)ap`以告诉编译器，以`ap`为首地址的那块内存我们要将之视为一个整型来使用，`(int)ap`获得该参数的值；接下来的变参是5，又一个int型，其地址是`ap + sizeof(第一个变参)`，也就是`ap + sizeof(int)`，同样我们使用`(int)ap`获得该参数的值；最后的一个参数是一个字符串，也就是`char`，与前两个`int`型参数不同的是，经过`ap + sizeof(int)`后，`ap`指向栈上一个`char`类型的内存块\(我们暂且称之`tmp_ptr`\)的首地址，即`ap -> &tmp_ptr`，而我们要输出的不是`printf("%s\n", ap)`，而是`printf("%s\n", tmp_ptr)`；`printf("%s\n", ap)`是意图将`ap`所指的内存块作为字符串输出了，但是`ap -> &tmp_ptr`，`tmp_ptr`所占据的4个字节显然不是字符串，而是一个地址。如何让`&tmp_ptr`是`char`类型的，我们将`ap`进行强制转换`(char)ap <=> &tmp_ptr`，这样我们访问`tmp_ptr`只需要在`(char`**`)ap`**前面加上一个即可，即`printf("%s\n", (char)ap)`。

> 该程序在GCC上不能输出预期的结果，但在VC上可以按预期输出。

## ✏ 2、内存对齐

### 🖋 2.1、字节对齐

现代计算机中内存空间都是按照byte划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。

各个硬件平台对存储空间的处理上有很大的不同。一些平台对某些特定类型的数据只能从某些特定地址开始存取。比如有些架构的CPU在访问一个没有进行对齐的变量的时候会发生错误，那么在这种架构下编程必须保证字节对齐。其他平台可能没有这种情况，但是最常见的是如果不按照适合其平台要求对数据存放进行对齐，会在存取效率上带来损失。比如有些平台每次读都是从偶地址开始，如果一个int型（假设为32位系统）如果存放在偶地址开始的地方，那 么一个读周期就可以读出这`32bit`，而如果存放在奇地址开始的地方，就需要2个读周期，并对两次读出的结果的高低字节进行拼凑才能得到该`32bit`数据，显然在读取效率上下降很多。



