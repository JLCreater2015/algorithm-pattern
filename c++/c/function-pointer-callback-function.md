# 函数指针与回调函数

## ✏ 1、指针函数

 **指针函数：** 本质是一个函数，不过它的返回值是一个指针。其声明的形式如下所示：

```cpp
ret *func(args, ...);
```

指针函数和普通函数没有区别，但有一点需要注意的是： **避免出现返回局部变量指针的情况。**看例子：

```cpp
int* getSum(int n)
{
    if (n < 0)
        return NULL;
    int sum = 0;   // static int sum = 0;
    for (int i = 0; i < n; i++)
    {
        sum += i;
    }
    return &sum;
}

int main() {
    cout << *getSum(10) << endl;
    cout << "Wait for a while...\n" << endl;
    int* iptr = getSum(10);
    cout << *iptr << endl;
    return 0;
}
```

在GCC编译器下没有输出，也就是说程序运行到第14行就强行退出了，原因在于，一般的局部变量是存放于栈区的，当函数结束，栈区的变量就会释放掉，如果我们在函数内部定义一个变量，在使用一个指针去指向这个变量，当函数调用结束时，这个变量的空间就已经被释放，这时就算返回了该地址的指针，也不一定会得到正确的值。并且该地址可能会被后面的程序所使用，这时候得到的就不是我们想要的结果。甚至更严重的是，如果因此访问到了不可访问的内容，很有可能造成段错误等程序崩溃的情况。（需要说明的是该程序在`VC++`编译器下可以正常运行，这与编译器的优化有关，但不符合C语言的特性）

解决方法，将局部变量sum声明成static int， 用`static`修饰的变量是静态变量，而静态变量是存放在数据段的，它的生命周期存在于整个程序运行期间，只要程序没有结束，该变量就会一直存在，所以该指针就能一直访问到该变量。还有一种解决方案是使用全局变量，因为全局变量也是放在数据段的，但是并不推荐使用全局变量。

## ✏ 2、函数指针

**函数指针** 的本质是一个指针，该指针的地址指向了一个函数。函数的定义是存在于代码段，因此，每个函数在代码段中有着自己的入口地址，**函数指针就是指向代码段中函数入口地址的指针。**其声明的形式如下所示：

```cpp
ret (*p)(args, ...);
```

 `ret`为返回值，`*p`作为一个整体，代表的是指向该函数的指针，`args`为形参列表。其中`p`被称为**函数指针变量** 。

1. `函数指针`的定义形式中的`数据类型`是指`函数的返回值的类型`。
2. `指向函数的指针变量`不是固定指向哪一个函数的，而只是表示定义了一个这样类型的变量，它是专门用来存放函数的入口地址的；在程序中把哪一个`函数的地址`赋给它，它就指向哪一个函数。
3. 在给函数指针变量赋值时，只需给出函数名，而不必给出参数。
4. 在一个程序中，`指针变量p`可以先后指向不同的函数，但一个函数不能赋给一个不一致的函数指针（`即不能让一个函数指针指向与其类型不一致的函数`）。
5. 定义了一个`函数指针`并让它`指向`了一个`函数`后，对函数的`调用`可以通过```函数名``调用```，也可以通过`函数指针调用`（即用指向函数的指针变量调用）。
6. 函数指针只能指向函数的入口处，而不可能指向函数中间的某一条指令。不能用`*(p+1)`来表示函数的下一条指令。
7. `函数指针变量`常用的用途之一是`把指针`作为`参数`传递到其他`函数`。

