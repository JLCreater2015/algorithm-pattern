---
description: 对C++11标准下的STL的使用方法进行学习和总结。（涉及到C++14标准和C++17标准的新特性会说明）
---

# STL基础

 STL，英文全称 `standard template library`，中文可译为标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。 STL 最初由惠普实验室开发，1998 年C++的第一个国际标准定版时，正式将STL纳入该标准。如今 STL 已完全被内置到支持 C++ 的编译器中，无需额外安装，这可能也是 STL 被广泛使用的原因之一。

> STL 就位于各个 C++ 的头文件中，即它并非以二进制代码的形式提供，而是以源代码的形式提供。

从根本上说，STL 是一些容器、算法和其他一些组件的集合，所有容器和算法都是总结了几十年来算法和数据结构的研究成果，汇集了许多计算机专家学者经验的基础上实现的，因此可以说，STL 基本上达到了各种存储方法和相关算法的高度优化。

## ✏ 发展历程

Alexander Stepanov（后被誉为 `STL` 标准模板库之父，后简称 Stepanov），1950 年出生与前苏联的莫斯科， 他曾在莫斯科大学研究数学，此后一直致力于计算机语言和泛型库研究。

1987 年，在贝尔实验室工作的 Stepanov 开始首次采用 C++ 语言进行泛型软件库的研究。由于当时的 C++ 语言还没有引入模板的编程技术，泛型库只能是通过 C++ 的继承机制来开发，代码表达起来非常笨拙。但尽管如此，Stepanov 还是开发出了一个庞大的算法库。与此同时，在与 Andrew Koenig（前 ISO C++ 标准化委员会主席）和 Bjarne Stroustrup（C++ 语言的创始人）等顶级大师们的共事过程中，Stepanov 开始注意到 C/C++ 语言在实现其泛型思想方面所具有的潜在优势。就拿 C/C++ 中的指针而言，它的灵活与高效运用使后来的 STL 在实现泛型化的同时更是保持了高效率。另外，在 STL 中占据极其重要地位的迭代器概念便是源自于 C/C++ 中原生指针的一般化推广。

1988 年，进入惠普的 `Palo Alto` 实验室工作，1992 年，他参加并主持了实验室主任 Bill Worley 所建立的一个有关算法的研究项目，项目自建立之后，参与者从最初的 8 人逐渐减少，最后只剩下 Stepanov 和 Meng Lee 两个人，经过长时间的努力，最终完成了一个包含有大量数据结构和算法部件的庞大运行库（HP 版本的 C++ STL），这便是现在 STL 的雏形。

1993 年，当时在贝尔实验室的 Andrew Koenig 看到了 Stepanov 的研究成果，在他的鼓励与帮助下，Stepanov 于 1993 年 9 月在圣何塞为 ANSI/ISO C++ 标准委员会做了一个题为`“The Science of C++ Programming”` 的演讲，向委员们讲述了他的观念。然后又于 1994 年 3 月，在圣迭戈会议上向委员会提交了一份建议书，以期将 STL 通用库纳入 C++ 标准。

尽管这一建议十分庞大，以至于降低了被通过的可能性，但其所包含的新思想吸引了许多人的注意力。随后在众人的帮助之下，包括 Bjame Stroustrup 在内，Stepanov 又对 STL 进行了改进，同时加入了一个封装内存模式信息的抽象模块，也就是现在 STL 中的 allocator（内存分配器），它使 STL 的大部分实现都可以独立于具体的内存模式，从而独立于具体平台。

最终在 1994 年的滑铁卢会议上，委员们通过了提案，决定将 STL 正式纳入 C++ 标准化进程之中，随后 STL 便被放进了会议的工作文件中。自此，STL 终于成为 C++ 家族中的重要一员。此后，随者 C++ 标准的不断改进，STL 也在不断地做着相应的演化。直至 1998 年，`ANSI/ISO C++` 标准正式定案，STL 成为 C++ 标准库的重要组成部分。

## ✏ 实现版本

自 1998 年 `ANSI/ISO C++` 标准正式定案，`C++ STL` 规范版本正式通过以后，由于其实开源的，各个 C++ 编译器厂商在此标准的基础上，实现了满足自己需求的 `C++ STL` 泛型库，主要包括 `HP STL、SGI STL、STLport、PJ STL、Rouge Wave STL` 等。

### HP STL

HP STL 是 Alexandar Stepanov 在惠普 Palo Alto 实验室工作时，与 Meng Lee 合作完成的。`HP STL` 是开放源码的，即任何人都可以免费使用、复制、修改、发布和销售该软件以及相关文档，但前提是必须在相关文档中，加入 `HP STL` 版本信息和授权信息。`HP STL` 是 `C++ STL` 的第一个实现版本，其它版本的 `C++ STL` 一般是以 `HP STL` 为蓝本实现出来的。不过，现在已经很少直接使用此版本的 STL 了。

### SGI STL

Stepanov 在离开 HP 之后，就加入到了 SGI 公司，并和 Matt Austern 等人开发了 SGI STL。严格意义上来说，它是 `HP STL` 的一个继承版本。和 HP STL 一样，`SGI STL` 也是开源的，其源代码的可读性可非常好，并且任何人都可以修改和销售它。和 STL 官方版本来说，`SGI STL` 只能算是一个“民间”版本，因此并不是所有支持 C++ 的编译器都支持使用 `SGI STL` 模板库，唯一能确定的是，GCC 是支持这一版本的，所以 `SGI STL` 在 Linux 平台上的性能非常出色。

### STLport

为了使 SGI STL 的基本代码都适用于 `VC++` 和 `C++ Builder` 等多种编译器，俄国人 Boris Fomitchev 建立了一个开源项目来开发 STLport，此版本 STL 是开放源码的。

### PJ STL

`PJ STL`（全称为 P.J. Plauger STL）是由 P.J.Plauger（美国人，1965 年毕业于普林斯顿大学，物理专业学士）参照 `HP STL` 实现出来的，也是 `HP STL` 的一个继承版本，因此该头文件中不仅含有 `HP STL` 的相关授权信息，同时还有 P.J.Plauger 本人的版权信息。其实 PJ STL 是 P.J.Plauger 公司的产品，尽管该公司当时只有 3 个人。`PJ STL` 被 `Visual C++` 编译器所采用，但和 `PH STL、SGI STL` 不同的是，`PJ STL` 并不是开源的。

### Rouge Wave STL

该版本的 STL 是由 Rouge Wave 公司开发的，也是继承 HP STL 的一个版本，它也不是开源的。`Rouge Wave STL` 用于 `Borland C++ Builder` 编译器中，我们可以在 `C++ Builder` 的 `Inculde` 子目录中找到该 STL 的所有头文件。值得一提的是，尽管 `Rouge Wave STL` 的性能不是很好，但 `C++ Builder` 对 C++ 语言标准的支持还算不错，所以在一定程度上使 `Rouge Wave STL` 的表现得以改善。遗憾的是，由于 `Rouge Wave STL` 长期没有更新且不完全符合标准，因此 `C++ Builder` 在 6.0 版本时改用了 `STLport` 版本（之后的版本也都采用了 `STLport`），不过考虑到和之前版本的兼容，6.0 版本中依旧保留了 `Rouge Wave STL`。

## ✏ 内容

通常认为，STL 是由**容器、算法、迭代器、函数对象、适配器、内存分配器**这 6 部分构成，其中后面 4 部分是为前 2 部分服务的，它们各自的含义如表下表所示：

| STL的组成 | 含义 |
| :--- | :--- |
| 容器 | 一些封装数据结构的模板类，例如 `vector` 向量容器、`list` 列表容器等。 |
| 算法 | STL 提供了非常多（大约 100 个）的数据结构算法，它们都被设计成一个个的模板函数，这些算法在 std 命名空间中定义，其中大部分算法都包含在头文件 `<algorithm>` 中，少部分位于头文件 `<numeric>` 中。 |
| 迭代器 | 在 `C++ STL` 中，对容器中数据的读和写，是通过迭代器完成的，扮演着容器和算法之间的胶合剂。 |
| 函数对象 | 如果一个类将 \(\) 运算符重载为成员函数，这个类就称为函数对象类，这个类的对象就是函数对象（又称仿函数）。 |
| 适配器 | 可以使一个类的接口（模板的参数）适配成用户指定的形式，从而让原本不能在一起工作的两个类工作在一起。值得一提的是，容器、迭代器和函数都有适配器。 |
| 内存分配器 | 为容器类模板提供自定义的内存申请和释放功能，由于往往只有高级用户才有改变内存分配策略的需求，因此内存分配器对于一般用户来说，并不常用。 |

在惠普实验室最初发行的版本中，STL 被组织成 48 个头文件；但在 C++98 标准中，它们被重新组织为 13 个头文件：`<iterator>`、`<functional>`、`<vector>`、`<deque>`、`<list>`、`<queue>`、`<stack>`、`<set>`、`<map>`、`<algorithm>`、`<numeric>`、`<memory>`和`<utility>`。

按照 C++ 标准库的规定，所有标准头文件都不再有扩展名。以 `<vector>` 为例，此为无扩展名的形式，而 `<vector.h>` 为有扩展名的形式。但是，或许是为了向下兼容，或许是为了内部组织规划，某些 STL 版本同时存储具备扩展名和无扩展名的两份文件（例如 `Visual C++` 支持的 Dinkumware 版本同时具备 `<vector.h>` 和 `<vector>`）；甚至有些 STL 版本同时拥有 3 种形式的头文件（例如 SGI 版本同时拥有 `<vector>`、`<vector.h>` 和 `<stl_vector.h>`）；但也有个别的 STL 版本只存在包含扩展名的头文件（例如 `C++ Builder` 的 `Rauge Ware STL` 版本只有`<vector.h>`）。  


