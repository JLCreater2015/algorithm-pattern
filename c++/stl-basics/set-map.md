# set/map

## ✏ Map

`map`是一种关联式容器，存储的都是 `pair` 对象，也就是用 `pair` 类模板创建的键值对。 包括 C++ 基本数据类型（`int`、`double` 等）和使用结构体或类自定义的类型。

### 🖋 1、特点

1. `map` 容器存储的各个键值对，键的值既不能重复也不能被修改。换句话说，`map` 容器中存储的各个键值对不仅键的值独一无二，键的类型也会用 const 修饰，这意味着只要键值对被存储到 `map` 容器中，其键的值将不能再做任何修改。
2.  在使用 map 容器存储多个键值对时，该容器会自动根据各键值对的键的大小，按照既定的规则进行排序。默认情况下，`map` 容器选用`std::less<T>`排序规则（其中 `T` 表示键的数据类型），其会根据键的大小对所有键值对做**升序排序**。当然，根据实际情况的需要，我们可以手动指定 `map` 容器的排序规则，既可以选用 `STL`标准库中提供的其它排序规则（比如`std::greater<T>`），也可以自定义排序规则。

### 🖋 2、创建和初始化

### 🖋 3、成员方法

| 成员方法 | 功能 |
| :--- | :--- |
| `begin()` | 返回指向容器中第一个（注意，是已排好序的第一个）键值对的双向迭代器。如果 `map` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `end()` | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 `begin()` 结合使用。如果 `map` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `rbegin()` | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 `map` 容器用 `const` 限定，则该方法返回的是 `const` 类型的反向双向迭代器。 |
| `rend()` | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 `map` 容器用 `const` 限定，则该方法返回的是 `const` 类型的反向双向迭代器。 |
| `cbegin()` | 和 `begin()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的键值对。 |
| `cend()` | 和 `end()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的键值对。 |
| `crbegin()` | 和 `rbegin()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的键值对。 |
| `crend()` | 和 `rend()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的键值对。 |
| `find(key)` | 在 `map` 容器中查找键为 `key` 的键值对，如果成功找到，则返回指向该键值对的双向迭代器；反之，则返回和 `end()` 方法一样的迭代器。另外，如果 `map` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `lower_bound(key)` | 返回一个指向当前 `map` 容器中第一个大于或等于 `key` 的键值对的双向迭代器。如果 `map` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `upper_bound(key)` | 返回一个指向当前 `map` 容器中第一个大于 `key` 的键值对的迭代器。如果 `map` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `equal_range(key)` | 该方法返回一个 pair 对象（包含 2 个双向迭代器），其中 `pair.first` 和 `lower_bound()` 方法的返回值等价，`pair.second` 和 `upper_bound()` 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的键为 `key` 的键值对（`map` 容器键值对唯一，因此该范围最多包含一个键值对）。 |
| `empty()`  | 若容器为空，则返回 `true`；否则 `false`。 |
| `size()` | 返回当前 `map` 容器中存有键值对的个数。 |
| `max_size()` | 返回 `map` 容器所能容纳键值对的最大个数，不同的操作系统，其返回值亦不相同。 |
| `operator[]` | `map`容器重载了 `[]` 运算符，只要知道 `map` 容器中某个键值对的键的值，就可以向获取数组中元素那样，通过键直接获取对应的值。 |
| `at(key)` | 找到 `map` 容器中 `key` 键对应的值，如果找不到，该函数会引发 `out_of_range` 异常。 |
| `insert()` | 向 `map` 容器中插入键值对。 |
| `erase()` | 删除 `map` 容器指定位置、指定键（key）值或者指定区域内的键值对。 |
| `swap()` | 交换 2 个 `map` 容器中存储的键值对，这意味着，操作的 2 个键值对的类型必须相同。 |
| `clear()` | 清空 `map` 容器中所有的键值对，即使 `map` 容器的 `size()`为 `0`。 |
| `emplace()` | 在当前 `map` 容器中的指定位置处构造新键值对。其效果和插入键值对一样，但效率更高。 |
| `emplace_hint()` | 在本质上和 `emplace()` 在 `map` 容器中构造新键值对的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示键值对生成位置的迭代器，并作为该方法的第一个参数。 |
| `count(key)` | 在当前 `map` 容器中，查找键为 `key` 的键值对的个数并返回。注意，由于 `map`容器中各键值对的键的值是唯一的，因此该函数的返回值最大为 `1`。 |

### 🖋 4、迭代器

## ✏ Set

`set`也是一种关联式容器，`set`容器中只能存储键，是单纯的键的集合，其中键是不能重复的。

### 🖋 1、特点

1. 所有的元素都会被自动排序。
2. 不能通过迭代器来改变set的值，因为set的值就是键。从语法上讲 set 容器并没有强制对存储元素的类型做 const 修饰，即 set 容器中存储的元素的值是可以修改的。但是，C++ 标准为了防止用户修改容器中元素的值，对所有可能会实现此操作的行为做了限制，使得在正常情况下，用户是无法做到修改 set 容器中元素的值的。

> 如果`set`中允许修改键值的话，那么首先需要删除该键，然后调节平衡，在插入修改后的键值，再调节平衡，如此一来，严重破坏了`set`的结构，导致`iterator`失效，不知道应该指向之前的位置，还是指向改变后的位置。所以`STL`中将`set`的迭代器设置成`const`，不允许修改迭代器的值。

### 🖋 2、创建和初始化

### 🖋 3、成员方法

| 成员方法 | 功能 |
| :--- | :--- |
| `begin()` | 返回指向容器中第一个（注意，是已排好序的第一个）元素的双向迭代器。如果 `set` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `end()` | 返回指向容器最后一个元素（注意，是已排好序的最后一个）所在位置后一个位置的双向迭代器，通常和 `begin()` 结合使用。如果 `set` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `rbegin()` | 返回指向最后一个（注意，是已排好序的最后一个）元素的反向双向迭代器。如果 `set`容器用 `const` 限定，则该方法返回的是 `const` 类型的反向双向迭代器。 |
| `rend()` | 返回指向第一个（注意，是已排好序的第一个）元素所在位置前一个位置的反向双向迭代器。如果 `set` 容器用 `const` 限定，则该方法返回的是 `const` 类型的反向双向迭代器。 |
| `cbegin()` | 和 `begin()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的元素值。 |
| `cend()` | 和 `end()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的元素值。 |
| `crbegin()` | 和 `rbegin()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的元素值。 |
| `crend()` | 和 `rend()` 功能相同，只不过在其基础上，增加了 `const` 属性，不能用于修改容器内存储的元素值。 |
| `find(val)` | 在 `set` 容器中查找值为 `val` 的元素，如果成功找到，则返回指向该元素的双向迭代器；反之，则返回和 `end()` 方法一样的迭代器。另外，如果 `set` 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `lower_bound(val)` | 返回一个指向当前 `set` 容器中第一个大于或等于 `val` 的元素的双向迭代器。如果 set 容器用 `const` 限定，则该方法返回的是 `const` 类型的双向迭代器。 |
| `upper_bound(val)` | 返回一个指向当前 `set` 容器中第一个大于 `val` 的元素的迭代器。如果 `set` 容器用 `const` 限定，则该方法返回的是 `const`类型的双向迭代器。 |
| `equal_range(val)` | 该方法返回一个 `pair` 对象（包含 2 个双向迭代器），其中 `pair.first` 和 `lower_bound()` 方法的返回值等价，`pair.second` 和 `upper_bound()` 方法的返回值等价。也就是说，该方法将返回一个范围，该范围中包含的值为 `val` 的元素（`set` 容器中各个元素是唯一的，因此该范围最多包含一个元素）。 |
| `empty()` | 若容器为空，则返回 `true`；否则 `false`。 |
| `size()` | 返回当前 `set` 容器中存有元素的个数。 |
| `max_size()` | 返回 `set` 容器所能容纳元素的最大个数，不同的操作系统，其返回值亦不相同。 |
| `insert()` | 向 `set` 容器中插入元素。 |
| `erase()` | 删除 `set` 容器中存储的元素。 |
| `swap()` | 交换 2 个 `set` 容器中存储的所有元素。这意味着，操作的 2 个 `set` 容器的类型必须相同。 |
| `clear()` | 清空 `set` 容器中所有的元素，即令 `set` 容器的 `size()` 为 `0`。 |
| `emplace()` | 在当前 `set` 容器中的指定位置直接构造新元素。其效果和 `insert()` 一样，但效率更高。 |
| `emplace_hint()` | 在本质上和 `emplace()` 在 `set` 容器中构造新元素的方式是一样的，不同之处在于，使用者必须为该方法提供一个指示新元素生成位置的迭代器，并作为该方法的第一个参数。 |
| `count(val)` | 在当前 `set` 容器中，查找值为 `val` 的元素的个数，并返回。注意，由于 `set` 容器中各元素的值是唯一的，因此该函数的返回值最大为 `1`。 |

### 🖋 4、迭代器

`set` 容器类模板中未提供 `at()` 成员函数，也未对 `[]` 运算符进行重载。因此，要想访问 `set` 容器中存储的元素，只能借助 `set` 容器的迭代器。

`C++ STL` 标准库为 set 容器配置的迭代器类型为双向迭代器。这意味着，假设 `p` 为此类型的迭代器，则其只能进行 `++p`、`p++`、`--p`、`p--`、`*p` 操作，并且 `2` 个双向迭代器之间做比较，也只能使用 `==` 或者 `!=` 运算符。

因为 `iter` 迭代器指向的是 `set` 容器存储的某个元素，而不是键值对，因此通过 `*iter` 可以直接获取该迭代器指向的元素的值。除此之外，如果只想遍历 `set` 容器中指定区域内的部分数据，则可以借助 `find()`、`lower_bound()` 以及 `upper_bound()` 实现。通过调用它们，可以获取一个指向指定元素的迭代器。需要特别指出的是，`equal_range(val)` 函数的返回值是一个 `pair` 类型数据，其包含 `2` 个迭代器，表示 `set` 容器中和指定参数 `val` 相等的元素所在的区域，但由于 set 容器中存储的元素各不相等，因此该函数返回的这 `2` 个迭代器所表示的范围中，最多只会包含 `1` 个元素。

虽然 `C++ STL` 标准中，`set` 类模板中包含 `lower_bound()`、`upper_bound()`、`equal_range()` 这 3 个成员函数，但它们更适用于 `multiset` 容器，几乎不会用于操作 `set` 容器。



